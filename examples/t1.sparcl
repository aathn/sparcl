data Nat = Z | S Nat 

sig add : Nat -o rev Nat -o rev Nat 
def add Z     y = y 
      | (S x) y = rev S (add x y)

def idNat = \x -> case x of 
    | Z -> Z 
    | S x -> S (idNat x) 
    end 

def fwd f = case unlift f of (x, _) -> x end 
def bwd f = case unlift f of (_, x) -> x end 


sig isZ : Nat -> Bool
def isZ Z  = True
      | _  = False 

sig mul : Nat # Omega -> rev Nat # 1 -> rev Nat 
def mul z (rev Z)   = rev Z with isZ
      | z (rev S y) = add z (mul z y)  

def q3 = fwd (mul (S (S Z))) (S (S Z))
def q4 = fwd (\x -> mul (S (S Z)) x) (S (S (S (S Z))))


def invert f = case unlift f of (x,y) -> lift y x end 
def exp0 = \x -> add (S Z) (mul (S (S Z)) x)

def q5 = fwd exp0
def q6 = bwd exp0 


def qm = 1 + 2 * 3 + 4 * 5 
def incL = lift (\x -> x + 1) (\x -> x - 1)

{-
We need some check of conformance C ||- D when 
we add type signatures, we know that this is decidable 
and at least in NP. 
-}
sig comp : forall p q r u a b c. () => 
--           (u ~ p * r) => 
           (b # p -> c) # q -> 
           (a # r -> b) # p -> 
           a # u -> c
def comp f g x = f (g x)