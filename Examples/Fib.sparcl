data Nat = Z | S Nat

sig add : Nat -> Nat <-> Nat
def add Z     *y = y
      | (S x) *y = S (add x |> y)

sig eqNat : Nat -> Nat -> Bool
def eqNat Z Z         = True
        | (S x) (S y) = eqNat x y
        | _     _     = False

sig fib : Nat <-> (Nat, Nat)
def fib Z     = (S Z, S Z) with \(x,y) -> eqNat x y
      | (S n) =
          let *(x, y) <- fib |> n in
            pin y' <- y in add y' |> x

def n0 = S (S (S Z)) -- 3
def p0  = fib |> n0
def n0' = fib <| p0

data Either a b = Left a | Right b

sig inPInt : Int <-> Either () Int
def inPInt = lift (\x -> case x of
                         | 0  -> Left ()
                         | x' -> Right (x' - 1)
                         end)
                  (\x -> case x of
                         | Left _ -> 0
                         | Right n -> n + 1 end)


sig addInt : Int -> Int <-> Int
def addInt n = lift (\a -> a + n) (\a -> a - n)

sig fibI : Int <-> (Int, Int)
def fibI *x = case inPInt |> x of
              | Left () -> (1, 1) with \(x,y) -> eqInt x y
              | Right n ->
                let *(x, y) <- fibI |> n in
                  pin y' <- y in addInt y' |> x
              end

def n1 = 3
def p1  = fibI |> n1
def n1' = fibI <| p1
