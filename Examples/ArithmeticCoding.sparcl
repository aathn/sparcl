type Range = (Rational , Rational)

-- ($) is useful for reducing paretheses.
def ($) = \f x -> f x
fixity $ 0 right

data Symbol = A | B | C | D | EOS

-- Hard-coded
sig rangeOf : Symbol -> Range
def rangeOf A   = (0 % 10, 6 % 10)
          | B   = (6 % 10, 8 % 10)
          | C   = (8 % 10, 9 % 10)
          | D   = (9 % 10, 999 % 1000)
          | EOS = (999 % 1000, 1 % 1)

sig find : Range -> Rational -> Symbol
def find (s , e) q =
    let q' <- (q -% s) /% (e -% s) in
    case ltRational q' (6 % 10) of
    | True -> A
    | False ->
      case ltRational q' (8 % 10) of
      | True -> B
      | False ->
        case ltRational q' (9 % 10) of
        | True -> C
        | False ->
          case ltRational q' (999 % 1000) of
          | True -> D
          | False -> EOS
          end
        end
      end
    end

sig narrow : Range -> Range -> Range
def narrow (l , r) (ls , rs) = (l +% (r -% l) *% ls, l +% (r -% l) *% rs)

sig narrowBySym : Range -> Symbol -> Range
def narrowBySym ran s = narrow ran (rangeOf s)

data List a = Nil | Cons a (List a)

sig encEOS : Range -> Rational
def encEOS ran =
    let (l',_) <- narrowBySym ran EOS
    in l'

-- Unidirectional Version
sig arithCompU : List Symbol -> Rational
def arithCompU = encodeU (0 % 1 , 1 % 1)

-- sig encodeU : Range -> List Symbol -> Rational
-- def encodeU (l, r) (Cons EOS Nil) = encEOS (l, r)
--          |  (l, r) (Cons s    ss) = encodeU (narrowBySym (l, r) s) ss

sig encodeU : Range -> List Symbol -> Rational
def encodeU (l, r) Nil         = l
          | (l, r) (Cons s ss) = encodeU (narrowBySym (l, r) s) ss

def origList = Cons A (Cons A (Cons B (Cons A (Cons C (Cons A (Cons B (Cons D (Cons A (Cons A (Cons EOS Nil))))))))))

sig delete : a -> a <-> ()
def delete c *a = (\*() -> c) <| a

sig deleteBy : (a -> b) -> (a, b) <-> a
def deleteBy f *(a, b) =
  let *(a , ()) <- pin a' <- a in delete (f a') |> b in
    a

sig eqSym : Symbol -> Symbol -> Bool
def eqSym A A = True
        | B B = True
        | C C = True
        | D D = True
        | EOS EOS = True
        | _  _ = False

sig arithCompR : List Symbol <-> Rational
def arithCompR = encodeR (0 % 1 , 1 % 1)

sig encodeR : Range -> List Symbol <-> Rational
def encodeR (l, r) Nil         = l with eqRational l
          | (l, r) (Cons s ss) =
            let *(s, q) <- pin s' <- s in encodeR (narrowBySym (l, r) s') |> ss
            in deleteBy (find (l, r)) |> (q, s)

def codeU = arithCompU origList
def code = arithCompR |> origList
def origList' = arithCompR <| code

sig eqList : (a -> a -> Bool) -> List a -> List a -> Bool
def eqList eqElem Nil Nil = True
         | eqElem (Cons a as) (Cons b bs) =
           case eqElem a b of
           | True  -> eqList eqElem as bs
           | False -> False
           end
         | _ _ _ = False

def check = eqList eqSym origList origList'

