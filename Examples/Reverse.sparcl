-- Various invertible definitions of the list reversal function. 
-- NB: "Loop.sparcl" also contains another version of reverse.

data List a = Nil | Cons a (List a) 

def fwd f = case unlift f of (x, _) -> x end 
def bwd f = case unlift f of (_, x) -> x end 

def null Nil = True
       | _   = False 

def mkList n = case eqInt n 0 of 
    | True -> Nil 
    | False -> Cons n (mkList (n-1))
    end 

def exampleList = fwd revSnoc (mkList 20)

def isSingle (Cons a Nil) = True
           | _            = False 

def snoc xs b = case xs of 
    | rev Nil      -> rev Cons b (rev Nil) with isSingle 
    | rev Cons a x -> rev Cons a (snoc x b) 
    end 

-- snoc-based reverse, which is easy to define but slow.
def revSnoc (rev Nil)       = rev Nil with null
          | (rev Cons a xs) = snoc (revSnoc xs) a 

data Nat = Z | S Nat 

def uncurryR f (rev (a, b)) = f a b 

def fst (a, _) = a 
def snd (_, b) = b 

def (.) f g = \x -> f (g x)

fixity . 90 right

-- linear reverse, based on "There and Back Again"-style 
-- The example is taken from:
--   K. Matsuda et al. "A Grammar-Based Approach to Invertible Programs", ESOP 10.

def revTaba = extract . uncurryR revWork . shape
  where
    def shape xs = case xs of 
       | rev Nil       -> rev (rev Z, rev Nil) with null . snd
       | rev Cons y ys -> 
              case shape ys of 
                   rev (n, zs) -> rev (rev S n, rev Cons y zs)
              end
       end 

    def revWork n xs = 
       case n of 
       | rev Z   -> rev (xs, rev Nil) with null . snd 
       | rev S m -> 
         case revWork m xs of 
         | rev (Cons x' xs', ys') -> rev (xs', rev Cons x' ys')
         end 
       end

    def extract (rev (Nil, xs)) = xs                  
  end

def testRevTABAf = fwd revHO exampleList 
def testRevTABAb = bwd revHO testRevTABAf -- must be equal to exampleList 

def tail (Cons _ xs) = xs 

-- reverse, with higher-order functions
def revHO = go (\z -> revWork z (rev Nil)) null 
    where
      sig go : (List (rev a) -o rev (List a)) -o (List a -> Bool) -> rev (List a) -o rev (List a) 
      def go f p z = case z of 
          | rev Nil      -> f Nil with p 
          | rev Cons a x -> go (\r -> f (Cons a r)) (p . tail) x
          end 

      def revWork xs r = case xs of 
          | Nil       -> r
          | Cons a xs -> revWork xs (rev Cons a r)
          end 
    end

def testRevHOf = fwd revHO exampleList
def testRevHOb = bwd revHO testRevHOf -- must be equal to exampleList 

data RList a = RList (List (rev a) -o rev (List a)) (Un (List a -> Bool))

sig rlToList : RList a -o rev (List a)
def rlToList (RList f (U _)) = f Nil

sig rlCons : rev a -o RList a -o RList a
def rlCons a (RList f (U p)) = RList (f . Cons a) (U (p . tail))

sig rlNil : RList a
def rlNil = RList (\xs -> go xs (rev Nil)) (U null)
  where
    def go xs r = case xs of
        | Nil       -> r
        | Cons a xs -> go xs (rev Cons a r)
        end
  end

sig rlGetP : RList a -o (RList a, Un (List a -> Bool))
def rlGetP (RList f (U p)) = (RList f (U p), U p)

-- reverse, with higher-order functions, reformulated
def revHO' = go rlNil
    where
      sig go : RList a -o rev (List a) -o rev (List a)
      def go l z = let (l, U p) <- rlGetP l in
          case z of
          | rev Nil      -> rlToList l with p
          | rev Cons a x -> go (rlCons a l) x
          end
    end

def drop n Nil        = Nil
       | n (Cons h t) =
         case eqInt 0 n of
         | True -> Cons h t
         | False -> drop (n - 1) t
         end

-- reverse with higher order functions, ad-hoc defunctionalized
def revHOWHO = go 0 (rev Nil)
    where
      sig go : Int -> rev (List a) -o rev (List a) -o rev (List a)
      def go n l z =
          case z of
          | rev Nil      -> l with null . drop n
          | rev Cons a x -> go (n + 1) (rev Cons a l) x
          end
    end

-- def revReader l = apR go (new eqInt 0) rev (rev Nil, l)
--     where
--       sig go : Reader Int (List a, List a) (List a)
--       def go = proc (rev (l, z)) ->
--           case z of
--           | rev Nil      -> returnA -< l with liftPR $ \(n, l) -> null . drop n $ l
--           | rev Cons h t -> localR plus1 go -< rev (rev Cons h l, t)
--           end
--       def plus1 = apR add (new eqInt 1)
--     end

data NullPred a =
    Null
  | Tail (NullPred a)

data FunList a =
    FNil
  | FCons (FunList a) (rev a)

sig evalNP : (NullPred a, List a) -> Bool
def evalNP (Null, l)    = null l
         | (Tail np, l) = evalNP (np, tail l)

sig evalFL : (FunList a, List (rev a)) -o rev (List a)
def evalFL (FNil, z)       = revWorkDF z (rev Nil)
         | (FCons fl a, r) = evalFL (fl, Cons a r)

-- reverse with higher-order functions, systematically defunctionalized
def revHODF = goDF FNil Null

sig goDF : FunList a -o NullPred a -> rev (List a) -o rev (List a)
def goDF f p z = case z of
  | rev Nil      -> evalFL (f, Nil) with \x -> evalNP (p, x)
  | rev Cons a x -> goDF (FCons f a) (Tail p) x
  end

def revWorkDF xs r = case xs of
  | Nil       -> r
  | Cons a xs -> revWorkDF xs (rev Cons a r)
  end

-- data RNullPred a =
--     Null
--   | Tail (NullPred a)

-- data RFunList a =
--     FNil
--   | FCons (FunList a) (rev a)

-- sig evalRNP : GFun (RNullPred a, List a) Bool
-- def evalRNP = *\(rev (np, l)) -> case np of
--   | Null    -> nullG * l
--   | Tail np -> let* t <- tailG * l in evalRNP * rev (np, t)
--   end

-- sig evalRFL : GFun (FunList a, List a) (List a)
-- def evalRFL = *\(rev (fl, l)) -> case fl of
--   | rev FNil -> revWorkRDF * rev (l, rev Nil)
--   | rev (FCons fl a) = evalRFL * rev (fl, rev Cons a l)
--   end

-- -- reverse with higher-order functions, systematically and reversibly defunctionalized
-- def revHODF = apR goRDF rev (rev FNil, rev Null)

-- sig goRDF : Reader (RFunList a, RNullPred a) (List a) (List a)
-- def goRDF f p z = case z of
--   | rev Nil      -> evalRFL (f, Nil) with \x -> evalRNP (p, x)
--   | rev Cons a x -> goRDF (rev FCons f a) (rev Tail p) x
--   end

-- def revWorkRDF = *\(xs, r) -> case xs of
--   | Nil       -> erase * xs; r
--   | Cons a xs -> revWorkRDF (xs, rev Cons a r)
--   end
