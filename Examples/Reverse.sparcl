data List a = Nil | Cons a (List a)

def null Nil = True
       | _   = False

def mkList n = case n of
    | 0 -> Nil
    | _ -> Cons n (mkList (n-1))
    end

def exampleList = revSnoc |> mkList 20

def isSingle (Cons a Nil) = True
           | _            = False

def snoc *(xs, b) = case xs of
    | Nil      -> Cons b Nil with isSingle
    | Cons a x -> Cons a (snoc |> (x, b))
    end

-- snoc-based reverse, which is easy to define but slow.
def revSnoc Nil         = Nil with null
          | (Cons a xs) = snoc |> (revSnoc |> xs, a)

data Nat = Z | S Nat

def fst (a, _) = a
def snd (_, b) = b

def (.) f g = \x -> f (g x)
fixity . 90 right

-- linear reverse, based on "There and Back Again"-style
-- The example is taken from:
--   K. Matsuda et al. "A Grammar-Based Approach to Invertible Programs", ESOP 10.

def revTaba *x = extract |> (revWork |> (shape |> x))
  where
    def shape *xs = case xs of
       | Nil       -> (Z, Nil) with null . snd
       | Cons y ys ->
           let *(n, zs) <- shape |> ys in
             (S n, Cons y zs)
       end

    def revWork *(n, xs) =
       case n of
       | Z   -> (xs, Nil) with null . snd
       | S m ->
         let *(Cons x' xs', ys') <- revWork |> (m, xs) in
           (xs', Cons x' ys')
       end

    def extract *(Nil, xs) = xs
  end

def testRevTABAf = revTaba |> exampleList
def testRevTABAb = revTaba <| testRevTABAf -- must be equal to exampleList

def tail (Cons _ xs) = xs

-- reverse, with higher-order functions
def revHO *x = go null |> (Nil, x)
    where
      sig go : (List a -> Bool) -> (List a, List a) <-> List a
      def go p *(l, z) = case z of
          | Nil      -> l with p
          | Cons a x -> go (p . tail) |> (Cons a l, x)
          end
    end

def testRevHOf = revHO |> exampleList
def testRevHOb = revHO <| testRevHOf -- must be equal to exampleList

