data Either a b = Left a
                | Right b

def fst (a, _) = a
def snd (_, b) = b

def (.) f g = \x -> f (g x)

data Nat = Z | S Nat

sig isZ : Nat -> Bool
def isZ Z = True
      | _ = False

sig isLeft : Either a b -> Bool
def isLeft (Left _) = True
         | _        = False

sig dup : a <-> (a, a)
def dup *a = pin a' <- a in a'

-- The trace operator mentioned in Section 3.6.4 in the paper.

sig trace : (Either a x <-> Either b x) -> a <-> b
def trace h *a =
    let *(a1, a2)  <- dup |> a in
    let *(b1, n)   <- go |> (h |> Left a1) in
    let *(Left b2) <- h |> (goN |> (a2, n)) in
      dup <| (b1, b2)
    where
        -- NB: currently, scoped type variables are not supported.
        -- sig go : rev (Either b x) -o rev (b, Nat)
        def go (Left b)  = (b, Z) with isZ . snd
             | (Right x) = let *(b, n) <- go |> (h |> Right x) in (b, S n)

        -- NB: currently, scoped type variables are not supported.
        -- sig goN : rev a -o rev Nat -o rev (Either a x)
        def goN (a, Z) = Left a with isLeft
              | (a, S n) = let *(Right x) <- h |> (goN |> (a, n)) in Right x
    end


data List a = Nil | Cons a (List a)

def null Nil = True
       | _   = False

def not False = True with \x -> x
      | True  = False

def revStep (Left Nil)   = Left Nil
  with \x -> case x of Left ys -> null ys |  _ -> False end
          | (Left xs)    = Right (xs, Nil)
  with \x -> case x of Right (_,ys) -> null ys | _ -> False end
          | (Right (Nil, ys))  = Left ys
  with \x -> case x of Left ys -> not (null ys) | _ -> False end
          | (Right (Cons a xs, ys)) = Right (xs, Cons a ys)
  with \x -> case x of Right (_,ys) -> not (null ys) | _ -> False end

sig reverseByTrace : List a <-> List a
def reverseByTrace = trace revStep

def t0  = Cons 1 (Cons 2 (Cons 3 Nil))
def rt0 = reverseByTrace |> t0
def t0' = reverseByTrace <| rt0 -- must be equal to t0


data B = B0 | B1

def double Z = Z with isZ
         | (S n) = S (S (double |> n))

def odd Z     = False
      | (S n) = even n

def even Z = True
       | (S n) = odd n

def msb2natStep
        (Left xs)        = Right (xs, Z) with \x -> case x of Right (_ , n) -> isZ n | _ -> False end
      | (Right (Nil, n)) = Left n                  with isLeft
      | (Right (Cons x xs, n)) =
          Right (xs, case x of B0 -> double |> n with even | B1 -> S (double |> n) with odd end)
          with \x -> case x of Right (_, n) -> not (isZ n) | _ -> False end



-- Assumption: the input has no preceding 0s, such as Cons B0 (Cons B1 Nil)
sig msb2nat : List B <-> Nat
def msb2nat = trace msb2natStep

def b6  = Cons B1 (Cons B1 (Cons B0 Nil))
def p6  = msb2nat |> b6
def b6' = msb2nat <| p6
