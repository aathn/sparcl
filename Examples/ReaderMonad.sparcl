def (.) f g = \x -> f (g x)
fixity . 90 right

def ($) = \f x -> f x
fixity $ 0 right

sig fst : forall a b. (a, b) -> a
def fst (x, _) = x

sig snd : forall a b. (a, b) -> b
def snd (_, x) = x

sig invert : forall a b. (rev a -o rev b) -> rev b -o rev a
def invert f = let (x, y) <- unlift f in lift y x

sig fwd : forall a b. (rev a -o rev b) -> a -> b
def fwd = fst . unlift

sig bwd : forall a b. (rev a -o rev b) -> b -> a
def bwd = snd . unlift

sig const : forall a p q. (a # p -> a # q -> Bool) -> a -> rev a
def const eq c =
  lift (\() -> c)
       (\c' -> let True <- eq c c' in ())
       (rev ())

sig pair : rev a -o rev b -o rev (a, b)
def pair a b = rev (a, b)

data List a = Nil | Cons a (List a)

sig null : List a -> Bool
def null Nil = True
       | _   = False

type Reader c a  = rev c -o rev (c, a)

sig return : rev a -o Reader c a
def return a c = rev (c, a)

sig bind : Reader c a -o (rev a -o Reader c b) -o Reader c b
def bind ra f c =
  let rev (c, a) <- ra c in
  f a c

sig withCtx : rev c -o Reader c a -o Reader d (c, a)
def withCtx c rc = return (rc c)

sig sub : rev Int -o Reader Int Int
def sub m n = pin n (\n' -> lift (\m -> m - n') (\m -> m + n') m)

sig goSubs : rev (List Int) -o Reader Int (List Int)
def goSubs l n =
  case l of
  | rev Nil -> return (rev Nil) n with null . snd
  | rev (Cons x xs) ->
    let reader <-
      bind (withCtx x (goSubs xs)) $ \xr n -> let rev (x, r) <- xr in
      (bind (sub x) $ \x' ->
       return (rev Cons x' r)) n
    in reader n
  end

sig subs : rev (List Int) -o rev (List Int)
def subs xs =
  let r0 <- const eqInt 0 in
  invert (pair r0) (goSubs xs r0)
