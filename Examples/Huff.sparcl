type Symbol = Char
data Huff = Lf Symbol | Br Huff Huff

data Bit = Z | O
data List a = Nil | Cons a (List a)

sig invert : forall a b. (a <-> b) -> b <-> a
def invert h *x = h <| x

sig decR : Huff -> List Bit <-> (Symbol, List Bit)
def decR (Lf s)   *ys = (s, ys)
       | (Br l r) *ys = case ys of
         | Cons Z ys' -> decR l |> ys' with \(s, _) ->  member s l
         | Cons O ys' -> decR r |> ys'
         end

sig encR : Huff -> (Symbol, List Bit) <-> List Bit
def encR h *(s, ys) = invert (decR h) |> (s, ys)

sig member : Symbol -> Huff -> Bool
def member s (Lf s')  = eqChar s s'
         | s (Br l r) =
           case member s l of
           | True  -> True
           | False -> member s r
           end

-- This dummy function always returns the same huffman tree. We could
-- implement usual construction of Huffman tree but this function is entirely
-- unidirectional.

sig makeHuff : List Symbol -> Huff
def makeHuff _ = Br (Lf 'a') (Br (Lf 'b') (Br (Lf 'c') (Lf 'd')))

sig huffCompress : List Symbol <-> (Huff, List Bit)
def huffCompress *s =
  let *(s, h) <- pin s' <- s in makeHuff s' in
  pin h' <- h in encode h' |> s

sig encode : Huff -> List Symbol <-> List Bit
def encode h Nil         = Nil with null
         | h (Cons s ss) = encR h |> (s, encode h |> ss)

sig null : forall a. List a -> Bool
def null Nil = True
       | _   = False


def origList = Cons 'a' (Cons 'a' (Cons 'b' (Cons 'a' (Cons 'c' (Cons 'a' (Cons 'b' (Cons 'd' (Cons 'a' (Cons 'a' Nil)))))))))

def t0 = huffCompress |> origList
def t1 = huffCompress <| t0
