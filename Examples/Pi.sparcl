data Tree = L | N Int Tree Tree
data List a = Nil | Cons a (List a)

sig (.) : (b -> c) -> (a -> b) -> a -> c
def (.) f g = \x -> f (g x)

def head (Cons x _) = x

def fst (x, y) = x
def snd (x, y) = y

sig null : forall a. List a -> Bool
def null Nil  = True
       | _    = False

sig piR : Tree <-> (List Int, List Int)
def piR L       = (Nil, Nil) with null . fst  -- (\(p,yy) -> null p)
      | (N a l r) =
        let *(pr, ir)      <- piR |> r in
        let *(a, (pl, il)) <- pin a' <- a in piAccSR a' |> (l, pr, ir) in
        (Cons a pl, il)

sig piAccSR : Int -> (Tree, List Int, List Int) <-> (List Int, List Int)
def piAccSR h *(t, py, iy) =
  case t of
  | L -> (py, Cons h iy)
    with eqInt h . head . snd
  | N a l r ->
    let *(pr, ir)      <- piAccSR h |> (r, py, iy) in
    let *(a, (pl, il)) <- pin a' <- a in piAccSR a' |> (l, pr, ir) in
    (Cons a pl, il)
  end

def pitrav x = piR |> x
def piinv  x = piR <| x

def t0 = N 0 (N 1 (N 2 L L) (N 3 L L)) (N 4 L L)

def tr0 = pitrav t0

def t0' = piinv tr0 -- must be equal to t0
