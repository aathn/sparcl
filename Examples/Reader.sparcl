def (.) f g = \x -> f (g x)
fixity . 90 right

def ($) = \f x -> f x
fixity $ 0 right

sig id : a # p -> a
def id x = x

sig fst : (a, b) -> a
def fst (x, _) = x

sig snd : (a, b) -> b
def snd (_, x) = x

sig inv : (rev a -o rev b) -> rev b -o rev a
def inv f = let (x, y) <- unlift f in lift y x

sig fwd : (rev a -o rev b) -> a -> b
def fwd = fst . unlift

sig bwd : (rev a -o rev b) -> b -> a
def bwd = snd . unlift

type Eq p q a = a # p -> a # q -> Bool

sig new : Eq p q a -> a -> rev a
def new eq c =
  lift (\() -> c)
       (\c' -> let True <- eq c c' in ())
       (rev ())

sig del : Eq p q a -> a -> rev a -o rev ()
def del eq c = inv (\(rev ()) -> new eq c)

sig copy : Eq p q a -> rev a -o rev (a, a)
def copy eqA a = pin a (new eqA)

sig mapPair : (rev a -o rev c) -o (rev b -o rev d) -o rev (a, b) -o rev (c, d)
def mapPair f g (rev (x, y)) = rev (f x, g y)

sig mapFst : (rev a -o rev b) -o rev (a, c) -o rev (b, c)
def mapFst f = mapPair f id

sig mapSnd : (rev a -o rev b) -o rev (c, a) -o rev (c, b)
def mapSnd f = mapPair id f

sig swap : rev (a, b) -o rev (b, a)
def swap (rev (a, b)) = rev (b, a)

sig pairr : rev a -o rev b -o rev (b, a)
def pairr a b = rev (b, a)

sig pairl : rev a -o rev b -o rev (a, b)
def pairl a = swap . pairr a

sig unitr : rev (x, ()) -o rev x
def unitr (rev (x, ())) = x

sig unitl : rev ((), x) -o rev x
def unitl = unitr . swap

sig assocr : rev ((a, b), c) -o rev (a, (b, c))
def assocr (rev ((a, b), c)) = rev (a, rev (b, c))

sig assocl : rev (a, (b, c)) -o rev ((a, b), c)
def assocl = inv assocr

sig shuffler : rev (a, (b, c)) -o rev (b, (a, c))
def shuffler = assocr . mapFst swap . assocl

sig shufflel : rev ((a, b), c) -o rev ((a, c), b)
def shufflel = assocl . mapSnd swap . assocr

data Either a b = Left a | Right b

sig isLeft : Either a b -> Bool
def isLeft (Left _) = True
         | _        = False

sig eitherToBool : rev (Either a a) -o rev (a, Bool)
def eitherToBool (rev Left  a) = rev (a, rev True) with snd
               | (rev Right a) = rev (a, rev False)

sig mirror : rev (Either a b) -o rev (Either b a)
def mirror (rev Right a) = rev Left a with isLeft
         | (rev Left a)  = rev Right a

sig distr : rev (Either a b, c) -o rev (Either (a, c) (b, c))
def distr (rev (Left  a, c)) = rev Left  rev (a, c) with isLeft
        | (rev (Right b, c)) = rev Right rev (b, c)

sig mapEither
  : (rev a -o rev c) -> (rev b -o rev d) -> rev (Either a b) -o rev (Either c d)
def mapEither f g (rev Left a)  = rev Left  (f a) with isLeft
            | f g (rev Right b) = rev Right (g b)

sig mapLeft  : (rev a -o rev b) -> rev (Either a c) -o rev (Either b c)
def mapLeft  f = mapEither f id

sig mapRight : (rev a -o rev b) -> rev (Either c a) -o rev (Either c b)
def mapRight f = mapEither id f

data List a = Cons a (List a) | Nil

sig null : List a -> Bool
def null Nil = True
       | _   = False

type CFun a b = rev a -o rev (a, b)

sig arrC : Eq p q a -> (rev a -o rev b) -o CFun a b
def arrC eqA f = mapSnd f . copy eqA

sig (.>>) : (rev a -o rev b) -> CFun b c -o CFun a c
def (.>>) fa fb = mapFst (inv fa) . fb . fa

sig (>>.) : CFun a b -o (rev b -o rev c) -o CFun a c
def (>>.) fa fb = mapSnd fb . fa

sig extendC : CFun a b -o CFun (a', a) b
def extendC cf = assocl . mapSnd cf

sig compC : (rev a -o rev (d, b)) -> CFun b c -o CFun a c
def compC fa fb = fa .>> extendC fb

sig (>>%) : CFun a b -> CFun b c -o CFun a c
def (>>%) = compC

sig firstC : Eq p q d -> CFun a b -o CFun (a, d) (b, d)
def firstC eqD cf =
  assocl . mapSnd (assocr . mapFst swap . assocl) . assocr . mapPair cf (copy eqD)

sig secondC : Eq p q d -> CFun a b -o CFun (d, a) (d, b)
def secondC eqD cf = swap .>> firstC eqD cf >>. swap

sig caseC : CFun a c -> CFun b c -> CFun (Either a b) c
def caseC fa fb = inv distr . mapEither fa fb

sig revBool : Bool -o rev Bool
def revBool True  = rev True
          | False = rev False

sig liftP' : (a # p -> Bool) -> CFun a Bool
def liftP' p a = pin a (revBool . p)

data GFun a b where
  sig GF : (rev a -o rev (g, b)) -o GFun a b
end

sig arrG : (rev a -o rev b) -o GFun a b
def arrG f = GF (inv unitl . f)

sig (>>!) : GFun a b -o GFun b c -o GFun a c
def (>>!) (GF fa) (GF fb) = GF (assocl . mapSnd fb . fa)

sig firstG : GFun a b -o GFun (a, d) (b, d)
def firstG (GF fa) = GF (assocr . mapFst fa)

sig secondG : GFun a b -o GFun (d, a) (d, b)
def secondG fa = arrG swap >>! firstG fa >>! arrG swap

sig caseG : GFun a c -> GFun b c -> GFun (Either a b) c
def caseG (GF fa) (GF fb) = GF (inv distr . mapEither fa fb)

sig erase : GFun a ()
def erase = GF (inv unitr)

sig fstG : GFun (a, b) a
def fstG = GF swap

sig sndG : GFun (a, b) b
def sndG = GF id

sig copyG : GFun a (a, a)
def copyG = arrG (copy (\_ _ -> True))

sig (>>!%) : GFun a b -> CFun b c -o CFun a c
def (>>!%) (GF fa) fb = compC fa fb

sig revPin : Eq p q b -> GFun a b -> CFun a b
def revPin eqB gf = gf >>!% copy eqB

sig suspendG : GFun a b -> GFun a b
def suspendG f = GF (\x -> revPin (\_ _ -> True) f x)

type Reader c x y = rev (c, x) -o rev (c, y)

sig arr : (rev a -o rev b) -o Reader c a b
def arr = mapSnd

sig (>>>) : Reader d a b -o Reader d b c -o Reader d a c
def (>>>) ra rb = rb . ra

sig first : Reader c a b -o Reader c (a, d) (b, d)
def first ra (rev (c, (a, d))) =
  let rev (c, b) <- ra rev (c, a) in
  rev (c, rev (b, d))

sig second : Reader c a b -o Reader c (d, a) (d, b)
def second ra = arr swap >>> first ra >>> arr swap

sig arrInv : Reader c a b -> Reader c b a
def arrInv = inv

sig left : Reader c a b -> Reader c (Either a d) (Either b d)
def left ra (rev (c, Left a)) =
         let rev (c, b) <- ra rev (c, a) in
         rev (c, rev Left b)
         with isLeft . snd
       | ra (rev (c, Right d)) = rev (c, rev Right d)

sig right : Reader c a b -> Reader c (Either d a) (Either d b)
def right ra = arr mirror >>> left ra >>> arr mirror

sig (+++) : Reader e a c -> Reader e b d -> Reader e (Either a b) (Either c d)
def (+++) ra rb = left ra >>> right rb

sig arrCase :
  Reader d c (c, Bool) -> Reader d a c -> Reader d b c -> Reader d (Either a b) c
def arrCase rbranch ra rb =
  (ra +++ rb) >>> arr eitherToBool >>> arrInv rbranch

sig caseR : Reader c1 a b -> Reader c2 a b -> Reader (Either c1 c2) a b
def caseR r1 r2 = inv distr . mapEither r1 r2 . distr

sig liftP : (a # p -> Bool) -> Reader c a (a, Bool)
def liftP = arr . liftP'

sig liftPR : ((c, a) # p -> Bool) -> Reader c a (a, Bool)
def liftPR p = assocr . liftP' p

sig localR : (rev s -o rev s') -> Reader s' a b -o Reader s a b
def localR f r = mapFst (inv f) . r . mapFst f

sig extendR : Reader s a b -o Reader (g, s) a b
def extendR r = assocl . mapSnd r . assocr

sig mutateR : GFun s s' -> Reader s' a b -o Reader s a b
def mutateR (GF f) = localR f . extendR

sig shrinkR : Reader (s, s') a b -o Reader s (s', a) (s', b)
def shrinkR r = assocr . r . assocl

sig updateR : GFun (s, a) s' -> Reader s' b c -o Reader s (a, b) (a, c)
def updateR gf = shrinkR . mutateR gf

sig pinR : Eq p q s' -> GFun (s, a) s' -> Reader s a (a, s')
def pinR eqS' gf = assocr . revPin eqS' gf
  -- = arr (inv unitr) >>> updateR gf (ask eqS') >>> second (arr unitr)

sig liftR : Reader c a b -o Reader d (c, a) (c, b)
def liftR = shrinkR . extendR
  -- = arr = updateR sndG

sig ask : Eq p q c -> Reader c a (c, a)
def ask eq = assocr . mapFst (copy eq)

sig apR : Reader c x y -o rev c -> rev x -o rev y
def apR r c = inv (pairl c) . r . pairl c

sig fromReader : Eq p q c -> Reader c x y -o c -> rev x -o rev y
def fromReader eqC r c x = let c' <- new eqC c in apR r c' x

sig toReader : (c -> rev x -o rev y) -o Reader c x y
def toReader f (rev (c, x)) = pin c (\c' -> f c' x)

sig add : Reader Int Int Int
def add = lift (\(m, n) -> (m, n + m)) (\(m, n) -> (m, n - m))

sig sub : Reader Int Int Int
def sub = arrInv add

sig succ : rev Int -o rev Int
def succ = apR add (new eqInt 1)

sig pred : rev Int -o rev Int
def pred = inv succ

sig is0 : rev Int -o rev (Either () Int)
def is0 =
  mapLeft (del eqInt 0) . inv eitherToBool . liftP' (eqInt 0)

sig ltIntC : CFun (Int, Int) Bool
def ltIntC  = liftP' (\(x, y) -> ltInt x y)

sig eqCharC : CFun (Char, Char) Bool
def eqCharC = liftP' (\(x, y) -> eqChar x y)

-- sig goSubs : Reader Int (List Int) (List Int)
-- def goSubs = proc l -> case l of
--   | rev Nil -> returnA -< rev Nil with null
--   | rev (Cons x xs) -> do
--     rev (x, r) <- liftR goSubs -< rev (x, xs)
--     x' <- sub -< x
--     returnA -< rev Cons x' r
--   end

-- sig goSubs : Reader Int (List Int) (List Int)
-- def goSubs = *\l -> case l of
--   | rev Nil -> [rev Nil] with null
--   | rev (Cons x xs) ->
--     *let rev (x, r) <- liftR goSubs * [rev (x, xs)] in
--     *let rev x' <- sub * [x] in
--     [rev Cons x' r]
--   end

sig goSubs : Reader Int (List Int) (List Int)
def goSubs =
  arr uncons >>>
  arrCase (liftP null)
    (arr (\(rev ()) -> rev Nil))
    (liftR goSubs >>>
      first sub >>>
        arr (\(rev (x, r)) -> rev Cons x r))

sig subs : rev (List Int) -o rev (List Int)
def subs = apR goSubs (new eqInt 0)

sig uncons : rev (List a) -o rev (Either () (a, List a))
def uncons (rev Nil)         = rev Left  rev () with isLeft
         | (rev (Cons x xs)) = rev Right rev (x, xs)

data Tree = L | N Int Tree Tree

sig piR : rev Tree -o rev (List Int, List Int)
def piR (rev L)       = rev (rev Nil, rev Nil) with null . fst
      | (rev N a l r) =
        let rev (pr, ir)      <- piR r in
        let rev (a, (pl, il)) <- piAccSR rev (a, rev (l, rev (pr, ir))) in
        rev (rev Cons a pl, il)

-- sig piAccSR : Reader Int (Tree, (List Int, List Int)) (List Int, List Int)
-- def piAccSR = proc (rev (t, pyiy)) -> case t of
--   | rev L -> do
--     rev (h, (py, iy)) <- ask eqInt -< pyiy
--     returnA -< rev (py, rev Cons h iy)
--     with liftPR $ \(h1, (_, Cons h2 _)) -> eqInt h1 h2
--   | rev (N a l r) -> do
--     rev prir          <- piAccSR -< rev (r, pyiy)
--     rev (a, (pl, il)) <- liftR piAccSR -< rev (a, rev (l, prir))
--     returnA -< rev (rev Cons a pl, il)
--   end

sig piAccSR : Reader Int (Tree, (List Int, List Int)) (List Int, List Int)
def piAccSR =
  first (arr untree) >>> arr distr >>>
  arrCase (liftPR $ \(h1, (_, Cons h2 _)) -> eqInt h1 h2)
    (arr unitl >>> ask eqInt >>>
     arr (\(rev (h, (py, iy))) -> rev (py, rev Cons h iy)))
    (arr assocr >>> second piAccSR >>>
     arr assocr >>> liftR piAccSR >>>
     arr (\(rev (a, (pl, il))) -> rev (rev Cons a pl, il)))

sig untree : rev Tree -o rev (Either () ((Int, Tree), Tree))
def untree (rev L)         = rev Left  rev () with isLeft
         | (rev (N a l r)) = rev Right rev (rev (a, l), r)

type Symbol = Char
data Huff   = Lf Symbol | Br Huff Huff

sig member : Symbol -> Huff -> Bool
def member s (Lf s')  = eqChar s s'
         | s (Br l r) =
           case member s l of
           | True  -> True
           | False -> member s r
           end

sig eqHuff : Huff -> Huff -> Bool
def eqHuff (Lf s)   (Lf s') = eqChar s s'
        |  (Br l r) (Br l' r') =
          case eqHuff l l' of
          | True  -> eqHuff r r'
          | False -> False
          end
        |  _         _ = False

sig unhuff : rev Huff -o rev (Either Symbol (Huff, Huff))
def unhuff (rev Lf s)   = rev Left  s          with isLeft
         | (rev Br l r) = rev Right rev (l, r)

data Bit = Z | O

sig unbit : rev (List Bit) -o rev (Either (List Bit) (List Bit))
def unbit (rev Cons Z l) = rev Left  l with isLeft
        | (rev Cons O l) = rev Right l

-- sig decR : Reader Huff (List Bit) (Symbol, List Bit)
-- def decR = proc ys -> caseR of
--   | Lf _   -> ask eqChar -< ys
--   | Br _ _ -> case ys of
--     | rev (Cons Z ys') -> mutateR fstG decR -< ys'
--       with liftPR $ \((l, _), (s, _)) -> member s l
--     | rev (Cons O ys') -> mutateR sndG decR -< ys'
--     end
--   end

sig decR : Reader Huff (List Bit) (Symbol, List Bit)
def decR =
  localR unhuff $
    caseR
      (ask eqChar)
      (arr unbit >>>
       arrCase (liftPR $ \((l, _), (s, _)) -> member s l)
         (mutateR fstG decR)
         (mutateR sndG decR))

sig encR : Reader Huff (Symbol, List Bit) (List Bit)
def encR = arrInv decR

-- sig encode : Reader Huff (List Symbol) (List Bit)
-- def encode = proc l -> case l of
--   | rev Nil       -> returnA -< rev Nil with null
--   | rev Cons s ss -> do
--       rest <- encode -< ss
--       encR -< rev (s, rest)
--   end

sig encode : Reader Huff (List Symbol) (List Bit)
def encode =
  arr uncons >>>
  arrCase (liftP null)
    (arr (\(rev ()) -> rev Nil))
    (second encode >>> encR)

sig dummyHuff : Huff
def dummyHuff = Br (Lf 'a') (Br (Lf 'b') (Br (Lf 'c') (Lf 'd')))

sig makeHuff : rev (List Symbol) -o rev (List Symbol, Huff)
def makeHuff s = rev (s, new eqHuff dummyHuff)

sig huffCompress : rev (List Symbol) -o rev (Huff, List Bit)
def huffCompress = encode . swap . makeHuff


sig and : Bool -> Bool -> Bool
def and True True = True
      | _    _    = False

sig eqPair : Eq p q a -> Eq s t b -> (a, b) -> (a, b) -> Bool
def eqPair eqA eqB (a1, b1) (a2, b2) =
  case eqA a1 a2 of
  | True -> eqB b1 b2
  | False -> False
  end

sig head : List a -> a
def head (Cons h _) = h

sig eqList : Eq p q a -> List a -> List a -> Bool
def eqList eq Nil Nil = True
         | eq (Cons h1 t1) (Cons h2 t2) =
           case eq h1 h2 of
           | True  -> eqList eq t1 t2
           | False -> False
           end
         | eq _ _     = False

sig replicate : Int -> a -> List a
def replicate n x =
  case eqInt 0 n of
  | True -> Nil
  | False -> Cons x (replicate (n-1) x)
  end

-- sig length : GFun (List a) Int
-- def length = proc l -> case l of
--   | Nil -> returnA -< new eqInt 0
--   | Cons h t ->
--     rev () <- erase -< h
--     tlen <- length -< t
--     returnA -< succ tlen

sig lengthC : CFun (List a) Int
def lengthC =
  uncons .>>
  caseC
    (inv unitl >>. (\(rev ()) -> new eqInt 0))
    (sndG >>!% lengthC >>. succ)

sig lengthG : GFun (List a) Int
def lengthG =
  arrG uncons >>!
  caseG
    (arrG (\(rev ()) -> new eqInt 0))
    (sndG >>! suspendG length >>! arrG succ)

sig length : GFun (List a) Int
def length = GF lengthC

sig reverse : rev (List a) -o rev (List a)
def reverse l =
  let rev (l, len)  <- revPin eqInt length l in
  let rev (Nil, l') <- goReverse len l in l'
  where
    def goReverse n l =
      case is0 n of
      | rev Left  () -> rev (l, rev Nil) with null . snd
      | rev Right n  ->
        let rev (Cons h t, l') <- goReverse (pred n) l in
        rev (t, rev Cons h l')
      end
  end

-- def split = proc l -> case l of
--   | rev Nil      ->
--     returnA -< rev (rev Nil, rev Nil)
--     with \(x, y) -> and (null x) (null y)
--   | rev Cons h t ->
--     localR is0 $
--       caseR of
--       | Left  _ -> returnA -< rev (rev Nil, rev Cons h t)
--       | Right _ -> do
--         rev (hs, ts) <- localR pred split -< t
--         returnA -< rev (rev Cons h hs, ts)
--       end
--   end

sig split : Reader Int (List a) (List a, List a)
def split =
  arr uncons >>>
  arrCase (liftP $ \(x, y) -> and (null x) (null y))
    (arr (\(rev ()) -> rev (rev Nil, rev Nil)))
    (localR is0 $
      caseR
        (arr (\(rev (h, t)) -> rev (rev Nil, rev Cons h t)))
        (second (localR pred split) >>>
         arr (\(rev (h, (hs, ts))) -> rev (rev Cons h hs, ts))))

sig take : GFun (Int, List a) (List a)
def take = GF split >>! fstG

sig append : CFun (List Symbol, List Symbol) (List Symbol)
def append =
  (distr . mapFst uncons) .>>
  caseC
    (unitl .>> copy (eqList eqChar))
    (assocr .>> secondC eqChar append >>.
     (\(rev (h, rest)) -> rev Cons h rest))

data Maybe a = Nothing | Just a

sig isNothing : Maybe a -> Bool
def isNothing Nothing = True
            | _       = False

sig eqMaybe : Eq p q a -> Maybe a -> Maybe a -> Bool
def eqMaybe eq Nothing  Nothing  = True
          | eq (Just x) (Just y) = eq x y
          | eq _        _        = False

sig unmaybe : rev (Maybe a) -o rev (Either () a)
def unmaybe (rev Nothing) = rev Left rev () with isLeft
          | (rev Just x)  = rev Right x

data LZPair = Lit Symbol | Pair (Int, Int)

sig isLit : LZPair -> Bool
def isLit (Lit _) = True
        | _       = False

sig winLength : Int
def winLength = 2048

sig lz77 : rev (List Symbol) -o rev (List LZPair)
def lz77 input =
  let rev (Nil, output) <- goLz77 rev (rev Nil, input) in output

-- sig goLz77 : Reader (List Symbol) (List Symbol) (List LZPair)
-- def goLz77 = proc l -> case l of
--   | rev Nil      -> rev Nil with null
--   | rev Cons h t ->
--     rev ((h, t), pair) <- pinR eqMaybeIntPair maxMatch -< rev (h, t)
--     case pair of
--     | rev Nothing ->
--       rev (h, lzRest) <- updateR updateWindow goLz77 -< rev (h, t)
--       returnA -< rev Cons (rev Lit h) lzRest
--       with isLit . head
--     | rev Just (d, l) ->
--       rev (l, (match, rest)) <- liftR split -< rev (l, rev Cons h t)
--       rev (match, lzRest)    <- updateR updateWindow' goLz77 -< rev (match, rest)
--       p <- arrInv (pinR (eqList eqChar) getMatch) -< rev (rev (d, l), match)
--       returnA -< rev Cons (rev Pair p) lzRest
--     end
--   end
--  where
--    def eqMaybeIntPair = eqMaybe (eqPair eqInt eqInt)
--
--    def updateWindow = proc (rev (w, h)) ->
--      take -< rev (new eqInt winLength, rev Cons h w)
--
--    def updateWindow' = proc (rev (w, m)) ->
--      w' <- GF append -< rev (reverse m, w)
--      take -< rev (new eqInt winLength, w')
--  end

sig goLz77 : Reader (List Symbol) (List Symbol) (List LZPair)
def goLz77 =
  arr uncons >>>
  arrCase (liftP null)
    (arr (\(rev ()) -> rev Nil))
    (pinR eqMaybeIntPair maxMatch >>> arr (distr . mapFst unmaybe . swap) >>>
     arrCase (liftP $ isLit . head)
      (arr unitl >>> updateR updateWindow goLz77 >>>
       arr (\(rev (h, lzRest)) -> rev Cons (rev Lit h) lzRest))
      (second (arr (\(rev (h, t)) -> rev Cons h t)) >>> arr assocr >>>
       second (liftR split >>> second (updateR updateWindow' goLz77)) >>>
       arr (assocl . assocl) >>> first (arrInv (pinR (eqList eqChar) getMatch)) >>>
       arr (\(rev (p, lzRest)) -> rev Cons (rev Pair p) lzRest)))
  where
    def eqMaybeIntPair = eqMaybe (eqPair eqInt eqInt)

    def updateWindow =
      arrG (\(rev (w, h)) -> rev Cons h w) >>!
      arrG (pairl (new eqInt winLength)) >>! take

    def updateWindow' =
      arrG swap >>! firstG (arrG reverse) >>! GF append >>!
      arrG (pairl (new eqInt winLength)) >>! take
  end

sig maxMatch : GFun (List Symbol, (Symbol, List Symbol)) (Maybe (Int, Int))
def maxMatch =
  secondG (arrG (\(rev (h, t)) -> rev Cons h t)) >>!
  arrG (pairl (rev (new eqInt 0, new eqInt 0)) . pairl (rev Nil)) >>!
  GF goMaxMatch >>! firstG (arrG is0) >>! arrG distr >>!
  caseG
    (erase >>! arrG (\(rev ()) -> rev Nothing))
    (arrG (rev Just))
  where
    -- def goMaxMatch = proc (rev (bestMatch, (matchBuf, (window, input)))) ->
    --   case window of
    --   | Nil ->
    --     rev () <- erase -< rev (matchBuf, input)
    --     returnA -< bestMatch
    --   | Cons h t ->
    --     let matchBuf <- rev Cons h matchBuf in
    --     rev ((matchBuf, input), (matchBuf', input')) <- copyG -< rev (matchBuf, input) in
    --     newMatch <- updateMatch -< rev (bestMatch, rev (matchBuf', input'))
    --     goMaxMatch -< rev (newMatch, rev (matchBuf, rev (t, input)))
    --   end
    sig goMaxMatch : CFun ((Int, Int), (List Symbol, (List Symbol, List Symbol))) (Int, Int)
    def goMaxMatch =
      (distr . mapFst uncons . shuffler . mapSnd shuffler) .>>
      caseC
        (unitl .>> (fstG >>!% copy (eqPair eqInt eqInt)))
        ((assocl .
          mapSnd (shufflel . mapFst (mapFst (\(rev (wh, mb)) -> rev Cons wh mb) .
                                     shufflel) . assocl) . shuffler) .>>
         (firstG (secondG copyG >>! arrG assocl >>! firstG updateMatch) >>!%
          ((mapSnd (shuffler . swap) . assocr) .>> goMaxMatch)))

    -- def updateMatch = proc (rev ((d, l), (matchBuf, input))) -> do
    --   rev (newDist, matchBuf) <- copyG >>! firstG length -< matchBuf
    --   newMatch <- measureMatch -< rev (matchBuf, input)
    --   newLength <- length -< newMatch
    --   let rev ((l, newLength), lt) <- ltIntC rev (l, newLength) in
    --   case lt of
    --   | True -> do
    --     rev () <- erase -< rev (d, l)
    --     returnA -< rev (newDist, newLength)
    --   | False -> do
    --     rev () <- erase -< rev (newLength, matchBuf)
    --     returnA -< rev (d, l)
    --   end
    sig updateMatch : GFun ((Int, Int), (List Symbol, List Symbol)) (Int, Int)
    def updateMatch =
      secondG (firstG (copyG >>! firstG length) >>!
               arrG assocr >>! secondG measureMatch) >>!
      arrG (inv eitherToBool . mapFst (assocl . mapSnd shuffler) . assocl .
            mapSnd (assocl . mapSnd ltIntC . shuffler) . assocr) >>!
      caseG sndG fstG

    sig measureMatch : GFun (List Symbol, List Symbol) Int
    def measureMatch = firstG copyG >>! arrG assocr >>! GF goMeasureMatch
    def goMeasureMatch =
      (distr . mapFst uncons . shuffler) .>>
      caseC
        (unitl .>> (firstG copyG >>!% (assocr .>> goMeasureMatch)))
        ((distr . mapFst uncons . swap . assocl) .>>
          caseC
            (erase >>!% inv unitl >>. (\(rev ()) -> new eqInt 0))
            ((mapFst eqCharC . assocr .
              mapFst (assocr . mapFst (assocl . swap) . assocl) . assocl) .>>
             (firstG sndG >>!% ((inv eitherToBool . swap) .>>
              caseC
               ((swap . mapFst swap) .>> goMeasureMatch >>. succ)
               (erase >>!% inv unitl >>. (\(rev ()) -> new eqInt 0))))))
  end

-- sig getMatch : GFun (List Symbol, (Int, Int)) (List Symbol)
-- def getMatch = proc (rev (window, (d, l))) ->
--   matchBuf <- take -< rev (d, window)
--   repeatTake -< rev (l, reverse matchBuf)

sig getMatch : GFun (List Symbol, (Int, Int)) (List Symbol)
def getMatch =
  arrG (mapFst swap . assocl) >>! firstG (take >>! arrG reverse) >>!
  arrG swap >>! repeatTake

-- sig repeatTake : GFun (Int, List a) (List a)
-- def repeatTake = proc (rev (n, l)) -> ll <- copyG -< l; goRepeatTake -< rev (n, ll)
--   where
--     def goRepeatTake = proc (rev (n, (l1, l2))) -> case l2 of
--       | Nil      -> ll <- copyG -< l1; goRepeatTake -< rev (n, ll)
--       | Cons h t -> case is0 n of
--         | Left  () ->
--           rev () <- erase -< rev (l1, (h, t))
--           returnA -< rev Nil
--         | Right n  -> do
--           rest <- goRepeatTake -< rev (pred n, rev (l1, t))
--           returnA -< rev Cons h rest
--         end
--       end
--   end

sig repeatTake : GFun (Int, List Symbol) (List Symbol)
def repeatTake = secondG copyG >>! GF goRepeatTake
  where
    def goRepeatTake =
      (distr . mapFst uncons . swap . assocl) .>>
      caseC
        (unitl .>> (secondG copyG >>!% goRepeatTake))
        ((distr . mapFst is0 . assocr . swap) .>>
          caseC
            (erase >>!% inv unitl >>. (\(rev ()) -> rev Nil))
            ((mapSnd (mapFst pred) . swap . assocl . mapSnd (assocl . mapSnd swap)) .>>
             secondC eqChar goRepeatTake >>.
             \(rev (h, rest)) -> rev Cons h rest))
  end
