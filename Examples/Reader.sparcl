def (.) f g = \x -> f (g x)
fixity . 90 right

def ($) = \f x -> f x
fixity $ 0 right

sig id : a # p -> a
def id x = x

sig fst : (a, b) -> a
def fst (x, _) = x

sig snd : (a, b) -> b
def snd (_, x) = x

sig inv : (rev a -o rev b) -> rev b -o rev a
def inv f = let (x, y) <- unlift f in lift y x

sig fwd : (rev a -o rev b) -> a -> b
def fwd = fst . unlift

sig bwd : (rev a -o rev b) -> b -> a
def bwd = snd . unlift

sig new : (a # p -> a # q -> Bool) -> a -> rev a
def new eq c =
  lift (\() -> c)
       (\c' -> let True <- eq c c' in ())
       (rev ())

sig copy : (a # p -> a # q -> Bool) -> rev a -o rev (a, a)
def copy eqA a = pin a (new eqA)

sig mapPair : (rev a -o rev c) -o (rev b -o rev d) -o rev (a, b) -o rev (c, d)
def mapPair f g (rev (x, y)) = rev (f x, g y)

sig mapFst : (rev a -o rev b) -o rev (a, c) -o rev (b, c)
def mapFst f = mapPair f id

sig mapSnd : (rev a -o rev b) -o rev (c, a) -o rev (c, b)
def mapSnd f = mapPair id f

sig swap : rev (a, b) -o rev (b, a)
def swap (rev (a, b)) = rev (b, a)

sig pairr : rev a -o rev b -o rev (b, a)
def pairr a b = rev (b, a)

sig pairl : rev a -o rev b -o rev (a, b)
def pairl a = swap . pairr a

sig unitr : rev (x, ()) -o rev x
def unitr (rev (x, ())) = x

sig unitl : rev ((), x) -o rev x
def unitl = unitr . swap

sig assocr : rev ((a, b), c) -o rev (a, (b, c))
def assocr (rev ((a, b), c)) = rev (a, rev (b, c))

sig assocl : rev (a, (b, c)) -o rev ((a, b), c)
def assocl = inv assocr

data Either a b = Left a | Right b

sig isLeft : Either a b -> Bool
def isLeft (Left _) = True
         | _        = False

sig joinBranch : (a -> Bool) -> rev (Either a a) -o rev a
def joinBranch branchP (rev Left a)  = a with branchP
             | branchP (rev Right a) = a

sig mirror : rev (Either a b) -o rev (Either b a)
def mirror (rev Right a) = rev Left a with isLeft
         | (rev Left a)  = rev Right a

sig distr : rev (Either a b, c) -o rev (Either (a, c) (b, c))
def distr (rev (Left  a, c)) = rev Left  rev (a, c) with isLeft
        | (rev (Right b, c)) = rev Right rev (b, c)

data List a = Cons a (List a) | Nil

sig null : List a -> Bool
def null Nil = True
       | _   = False

type Reader c x y = rev (c, x) -o rev (c, y)

sig arr : (rev a -o rev b) -o Reader c a b
def arr = mapSnd

sig (>>>) : Reader d a b -o Reader d b c -o Reader d a c
def (>>>) ra rb = rb . ra

sig first : Reader c a b -o Reader c (a, d) (b, d)
def first ra (rev (c, (a, d))) =
  let rev (c, b) <- ra rev (c, a) in
  rev (c, rev (b, d))

sig second : Reader c a b -o Reader c (d, a) (d, b)
def second ra = arr swap >>> first ra >>> arr swap

sig (***) : Reader e a c -o Reader e b d -o Reader e (a, b) (c, d)
def (***) ra rb = first ra >>> second rb

sig arrFork : (a # p -> a # q -> Bool) -> Reader d a b -o Reader d a c -o Reader d a (b, c)
def arrFork eqA rb rc = arr (copy eqA) >>> (rb *** rc)

sig arrInv : Reader c a b -> Reader c b a
def arrInv = inv

sig left : Reader c a b -> Reader c (Either a d) (Either b d)
def left ra (rev (c, Left a)) =
         let rev (c, b) <- ra rev (c, a) in
         rev (c, rev Left b)
         with isLeft . snd
       | ra (rev (c, Right d)) = rev (c, rev Right d)

sig right : Reader c a b -> Reader c (Either d a) (Either d b)
def right ra = arr mirror >>> left ra >>> arr mirror

sig (+++) : Reader e a c -> Reader e b d -> Reader e (Either a b) (Either c d)
def (+++) ra rb = left ra >>> right rb

sig arrCase : (c -> Bool) -> Reader d a c -> Reader d b c -> Reader d (Either a b) c
def arrCase branchP ra rb = (ra +++ rb) >>> arr (joinBranch branchP)

-- type HFun a b = exist h g. rev (h, a) -o rev (g, b)

-- sig erase : HFun a ()
-- def erase = inv unitl

type CFun a b = rev a -o rev (a, b)

sig conjC : (rev a -o rev a') -> CFun a' b -o CFun a b
def conjC f cf = inv (mapFst f) . cf . f

sig extendC : CFun a b -o CFun (a, a') b
def extendC cf = assocl . mapSnd swap . assocr . mapFst cf

sig revPin : (rev a -o rev (a', h)) -> CFun a' b -o CFun a b
def revPin f = conjC f . extendC

sig conjR : (rev s -o rev s') -> Reader s' a b -o Reader s a b
def conjR f r (rev (s, a)) = conjC f (\s -> r rev (s, a)) s

sig extendR : Reader s a b -o Reader (s, s') a b
def extendR r (rev (ss', a)) = extendC (\s -> r rev (s, a)) ss'

sig mutateR : (rev s -o rev (s', h)) -> Reader s' a b -o Reader s a b
def mutateR f = conjR f . extendR

sig shrinkR : Reader (s, s') a b -o Reader s (s', a) (s', b)
def shrinkR r = assocr . r . assocl

sig localR : (rev (s, a) -o rev (s', h)) -> Reader s' b c -o Reader s (a, b) (a, c)
def localR f = shrinkR . mutateR f

sig liftR : Reader c a b -o Reader d (c, a) (c, b)
def liftR = localR swap -- = arr

sig get : (c # p -> c # q -> Bool) -> Reader c a (c, a)
def get eq = assocr . mapFst (copy eq)

sig assert : (c # p -> c # q -> Bool) -> Reader c (c, a) a
def assert eq = arrInv (get eq)

sig apR : Reader c x y -o rev c -> rev x -o rev y
def apR r c = inv (pairl c) . r . pairl c

sig fromReader : (c # p -> c # q -> Bool) -> Reader c x y -o c -> rev x -o rev y
def fromReader eqC r c x = let c' <- new eqC c in apR r c' x

sig toReader : (c -> rev x -o rev y) -o Reader c x y
def toReader f (rev (c, x)) = pin c (\c' -> f c' x)

-- sig goSubs : Reader Int (List Int) (List Int)
-- def goSubs = proc l -> do
--   case l of
--   | rev Nil -> returnA -< rev Nil with null
--   | rev (Cons x xs) -> do
--     rev (x, r) <- liftR goSubs -< rev (x, xs)
--     x' <- sub -< x
--     returnA -< rev Cons x' r
--   end

-- sig goSubs : Reader Int (List Int) (List Int)
-- def goSubs = *\l ->
--   case l of
--   | rev Nil -> [rev Nil] with null
--   | rev (Cons x xs) ->
--     *let rev (x, r) <- liftR goSubs * [rev (x, xs)] in
--     *let rev x' <- sub * [x] in
--     [rev Cons x' r]
--   end

sig goSubs : Reader Int (List Int) (List Int)
def goSubs =
  arr uncons >>>
  arrCase null
    (arr (\(rev ()) -> rev Nil))
    (liftR goSubs >>>
      first sub >>>
        arr (\(rev (x, r)) -> rev Cons x r))

sig subs : rev (List Int) -o rev (List Int)
def subs xs = apR goSubs (new eqInt 0) xs

sig sub : Reader Int Int Int
def sub = lift (\(m, n) -> (m, n - m)) (\(m, n) -> (m, n + m))

sig uncons : rev (List a) -o rev (Either () (a, List a))
def uncons (rev Nil)         = rev Left  rev () with isLeft
         | (rev (Cons x xs)) = rev Right rev (x, xs)

data Tree = L | N Int Tree Tree

sig piR : rev Tree -o rev (List Int, List Int)
def piR (rev L)       = rev (rev Nil, rev Nil) with null . fst
      | (rev N a l r) =
        let rev (pr, ir)      <- piR r in
        let rev (a, (pl, il)) <- piAccSR rev (a, rev (l, rev (pr, ir))) in
        rev (rev Cons a pl, il)

-- sig piAccSR : Reader Int (Tree, (List Int, List Int)) (List Int, List Int)
-- def piAccSR = proc (rev (t, pyiy)) -> do
--   case t of
--   | rev L -> do
--     rev (h, (py, iy)) <- get eqInt -< pyiy
--     get eqInt -< rev (py, rev Cons h iy)
--     with \(h1, (_, Cons h2 _)) -> eqInt h1 h2
--   | rev (N a l r) -> do
--     rev prir          <- piAccSR -< rev (r, pyiy)
--     rev (a, (pl, il)) <- liftR piAccSR -< rev (a, rev (l, prir))
--     get eqInt -< rev (rev Cons a pl, il)
--   end
--     >>> assert eqInt

sig piAccSR : Reader Int (Tree, (List Int, List Int)) (List Int, List Int)
def piAccSR =
  first (arr untree) >>> arr distr >>>
  arrCase (\(h1, (_, Cons h2 _)) -> eqInt h1 h2)
    (arr unitl >>> get eqInt >>>
     arr (\(rev (h, (py, iy))) -> rev (py, rev Cons h iy)) >>> get eqInt)
    (arr assocr >>> second piAccSR >>>
     arr assocr >>> liftR piAccSR >>>
     arr (\(rev (a, (pl, il))) -> rev (rev Cons a pl, il)) >>> get eqInt) >>>
  assert eqInt

sig untree : rev Tree -o rev (Either () ((Int, Tree), Tree))
def untree (rev L)         = rev Left  rev () with isLeft
         | (rev (N a l r)) = rev Right rev (rev (a, l), r)

type Symbol = Char
data Huff   = Lf Symbol | Br Huff Huff

sig isLf : Huff -> Bool
def isLf (Lf _) = True
       | _      = False

sig member : Symbol -> Huff -> Bool
def member s (Lf s')  = eqChar s s'
         | s (Br l r) =
           case member s l of
           | True  -> True
           | False -> member s r
           end

sig eqHuff : Huff -> Huff -> Bool
def eqHuff (Lf s)   (Lf s') = eqChar s s'
        |  (Br l r) (Br l' r') =
          case eqHuff l l' of
          | True  -> eqHuff r r'
          | False -> False
          end
        |  _         _ = False

sig unhuff : rev Huff -o rev (Either Symbol (Huff, Huff))
def unhuff (rev Lf s)   = rev Left  s          with isLeft
         | (rev Br l r) = rev Right rev (l, r)

data Bit = Z | O

sig unbit : rev (List Bit) -o rev (Either (List Bit) (List Bit))
def unbit (rev Cons Z l) = rev Left  l with isLeft
        | (rev Cons O l) = rev Right l

-- sig decR : Reader Huff (List Bit) (Symbol, List Bit)
-- def decR = proc ys -> do
--   rev (huff, ys) <- get eqHuff -< ys
--   case huff of
--   | rev Lf s   -> get eqHuff -< rev (s, ys) with isLf . fst
--   | rev Br l r ->
--     case ys of
--     | rev (Cons Z ys') -> do
--       rev (l, res) <- liftR decR -< rev (l, ys')
--       returnA -< rev (rev Br l r, res) with (\(Br l r, (s,_)) -> member s l)
--     | rev (Cons O ys') -> do
--       rev (r, res) <- liftR decR -< rev (r, ys')
--       returnA -< rev (rev Br l r, res)
--     end
--   end
--     >>> assert eqHuff

sig decR : Reader Huff (List Bit) (Symbol, List Bit)
def decR =
  get eqHuff >>> first (arr unhuff) >>> arr distr >>>
  arrCase (isLf . fst)
    (get eqHuff)
    (arr swap >>> first (arr unbit) >>> arr distr >>>
     arrCase (\(Br l r, (s,_)) -> member s l)
       (arr swap >>> first (arr swap) >>> arr assocr >>> second (liftR decR) >>>
        arr assocl >>> first (arr (\(rev (r, l)) -> rev Br l r)))
       (arr swap >>> arr assocr >>> second (liftR decR) >>>
        arr assocl >>> first (arr (\(rev (l, r)) -> rev Br l r)))) >>>
  assert eqHuff

sig encR : Reader Huff (Symbol, List Bit) (List Bit)
def encR = arrInv decR

-- sig encode : Reader Huff (List Symbol) (List Bit)
-- def encode = proc l ->
--   case l of
--   | rev Nil       -> returnA -< rev Nil with null
--   | rev Cons s ss -> do
--       rest <- encode -< ss
--       encR -< rev (s, rest)
--   end

sig encode : Reader Huff (List Symbol) (List Bit)
def encode =
  arr uncons >>>
  arrCase null
    (arr (\(rev ()) -> rev Nil))
    (second encode >>> encR)

sig dummyHuff : Huff
def dummyHuff = Br (Lf 'a') (Br (Lf 'b') (Br (Lf 'c') (Lf 'd')))

sig makeHuff : rev (List Symbol) -o rev (Huff, List Symbol)
def makeHuff s = rev (new eqHuff dummyHuff, s)

sig huffCompress : rev (List Symbol) -o rev (Huff, List Bit)
def huffCompress = encode . makeHuff


sig del : (a # p -> a # q -> Bool) -> a -> rev a -o rev ()
def del eq c = inv (\(rev ()) -> new eq c)

sig and : Bool -> Bool -> Bool
def and True True = True
      | _    _    = False

sig eqPair : (a # p -> a # q -> Bool) -> (b # s -> b # t -> Bool) -> (a, b) -> (a, b) -> Bool
def eqPair eqA eqB (a1, b1) (a2, b2) =
  case eqA a1 a2 of
  | True -> eqB b1 b2
  | False -> False
  end

data LZPair = Lit Symbol | Pair (Int, Int)

sig isLit : LZPair -> Bool
def isLit (Lit _) = True
        | _       = False

sig head : List a -> a
def head (Cons h _) = h

sig tail : List a -> List a
def tail (Cons _ t) = t

sig length : List a -> Int
def length Nil        = 0
         | (Cons _ t) = 1 + length t

sig repeatTake : Int -> List a -> List a
def repeatTake n l = goRepeatTake n l l
  where
    def goRepeatTake n l1 Nil        = goRepeatTake n l1 l1
                   | n l1 (Cons h t) =
                     case eqInt 0 n of
                     | True -> Nil
                     | False -> Cons h (goRepeatTake (n - 1) l1 t)
                     end
  end

sig revTake : Int -> List a -> List a
def revTake n l = goRevTake n l Nil
  where
    def goRevTake n Nil        acc = acc
                | n (Cons h t) acc =
                  case eqInt 0 n of
                  | True -> acc
                  | False -> goRevTake (n - 1) t (Cons h acc)
                  end
  end

sig eqList : (a # p -> a # q -> Bool) -> List a -> List a -> Bool
def eqList eq Nil Nil = True
         | eq (Cons h1 t1) (Cons h2 t2) =
           case eq h1 h2 of
           | True  -> eqList eq t1 t2
           | False -> False
           end
         | eq _ _     = False

data Maybe a = Nothing | Just a

sig isNothing : Maybe a -> Bool
def isNothing Nothing = True
            | _       = False

sig eqMaybe : (a # p -> a # q -> Bool) -> Maybe a -> Maybe a -> Bool
def eqMaybe eq Nothing  Nothing  = True
          | eq (Just x) (Just y) = eq x y
          | eq _        _        = False

sig unmaybe : rev (Maybe a) -o rev (Either () a)
def unmaybe (rev Nothing) = rev Left rev () with isLeft
          | (rev Just x)  = rev Right x

sig winLength : Int
def winLength = 2048

sig lz77 : rev (List Symbol) -o rev (List LZPair)
def lz77 input =
  let rev (Nil, output) <- goLz77 rev (rev Nil, input) in output

-- sig goLz77 : Reader (List Symbol) (List Symbol) (List LZPair)
-- def goLz77 = proc l ->
--   case l of
--   | rev Nil      -> rev Nil with null
--   | rev Cons h t ->
--     rev (pair, (h, t)) <- maxMatch -< rev (h, t)
--     case pair of
--     | rev Nothing ->
--       rev (oneH, lzRest) <- localR updateWindow goLz77 -< rev (rev (new eqInt 1, rev Cons h rev Nil), t)
--       let rev (Cons h Nil) <- inv (pairl (new eqInt 1)) oneH in
--       returnA -< rev Cons (rev Lit h) lzRest
--       with isLit . head
--     | rev Just (d, l) ->
--       rev (l, (match, rest))   <- liftR split -< rev (l, rev Cons h t)
--       rev ((l, match), lzRest) <- localR updateWindow goLz77 -< rev (rev (l, match), rest)
--       p                        <- deleteMatch -< rev (rev (d, l), match)
--       returnA -< rev Cons (rev Pair p) lzRest
--     end
--   end

sig goLz77 : Reader (List Symbol) (List Symbol) (List LZPair)
def goLz77 =
  arr uncons >>>
  arrCase null
    (arr (\(rev ()) -> rev Nil))
    (maxMatch >>> first (arr unmaybe) >>> arr distr >>>
     arrCase (isLit . head)
      (arr unitl >>> first (arr (\h -> rev Cons h rev Nil)) >>>
       arr (assocl . pairl (new eqInt 1)) >>>
       localR updateWindow goLz77 >>> arr (inv (pairl (new eqInt 1)) . assocr) >>>
       arr (\(rev (Cons h Nil, lzRest)) -> rev Cons (rev Lit h) lzRest))
      (second (arr (\(rev (h, t)) -> rev Cons h t)) >>> arr assocr >>>
       second (liftR split >>> arr assocl >>> localR updateWindow goLz77) >>>
       arr assocl >>> first (arr assocl >>> deleteMatch) >>>
       arr (\(rev (p, lzRest)) -> rev Cons (rev Pair p) lzRest)))

sig updateWindow : rev (List Symbol, (Int, List Symbol)) -o rev (List Symbol, (Int, List Symbol))
def updateWindow (rev (window, (len, match))) =
  let wl <- new eqInt winLength in
  let rev (len, (winit, wlast)) <-
    mutateR (inv swap . sub . swap . pairl wl) split rev (len, window) in
  let rev (len, newWin) <- concat rev (len, rev (reverse match, winit)) in
  rev (newWin, rev (len, wlast))

sig maxMatch : Reader (List Symbol) (Symbol, List Symbol) (Maybe (Int, Int), (Symbol, List Symbol))
def maxMatch wi =
  let rev ((window, input), pair) <-
    pin wi (\(window, (h, t)) -> new eqMaybeIntPair (maxMatch' window (Cons h t))) in
  rev (window, rev (pair, input))
  where
    def eqMaybeIntPair = eqMaybe (eqPair eqInt eqInt)
    def maxMatch' window input =
      let (d, l) <- goMaxMatch (0, 0) Nil window input in
        case eqInt 0 l of
          | True  -> Nothing
            | False -> Just (d, l)
        end

    def goMaxMatch bestMatch matchBuf Nil        input = bestMatch
                 | bestMatch matchBuf (Cons h t) input =
                   let matchBuf <- Cons h matchBuf in
                   let newMatch <- updateMatch bestMatch matchBuf input in
                   goMaxMatch newMatch matchBuf t input

    def updateMatch (d, l) matchBuf input =
      let newLength <- length (createMatch matchBuf matchBuf input) in
      case ltInt l newLength of
      | True -> (length matchBuf, newLength)
      | False -> (d, l)
      end

    def createMatch matchBuf Nil          input        = createMatch matchBuf matchBuf input
                  | matchBuf _            Nil          = Nil
                  | matchBuf (Cons h1 t1) (Cons h2 t2) =
                    case eqChar h1 h2 of
                    | True -> Cons h1 (createMatch matchBuf t1 t2)
                    | False -> Nil
                    end
  end

sig split : Reader Int (List Symbol) (List Symbol, List Symbol)
def split (rev (len, list)) = pin len (\l' -> split' l' list)
  where
    def split' _ (rev Nil)      = rev (rev Nil, rev Nil) with \(x, y) -> and (null x) (null y)
             | n (rev Cons h t) =
               case eqInt 0 n of
               | True -> rev (rev Nil, rev Cons h t)
               | False -> let rev (hs, ts) <- split' (n - 1) t in rev (rev Cons h hs, ts)
               end
  end

sig concat : Reader Int (List Symbol, List Symbol) (List Symbol)
def concat = arrInv split

sig revBool : Bool -o rev Bool
def revBool True  = rev True
          | False = rev False

sig eqIntC : CFun (Int, Int) Bool
def eqIntC p = pin p (\(x, y) -> revBool (eqInt x y))

sig reverse : rev (List Symbol) -o rev (List Symbol)
def reverse l =
  let rev (l, len)  <- pin l (new eqInt . length) in
  let rev (Nil, l') <- goReverse len l in l'
  where
    def goReverse n l =
      let rev (n, eq0) <- conjC (pairl (new eqInt 0)) eqIntC n in
      case eq0 of
      | rev True  ->
        let rev () <- del eqInt 0 n in
        rev (l, rev Nil) with null . snd
      | rev False ->
        let n' <- apR sub (new eqInt 1) n in
        case goReverse n' l of
        | rev (Cons h t, l') -> rev (t, rev Cons h l')
        end
      end
  end

sig deleteMatch : Reader (List Symbol) ((Int, Int), List Symbol) (Int, Int)
def deleteMatch (rev (window, (pair, match))) =
  let rev ((window, pair), ()) <- pin rev (window, pair)
    (\(window, pair) -> del (eqList eqChar) (getMatch window pair) match) in
  rev (window, pair)
  where
    def getMatch window (d, l) = repeatTake l (revTake d window)
  end
